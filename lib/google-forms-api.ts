// Google Forms API utility functions
import { 
  GoogleFormStructure, 
  GoogleForm, 
  ValidationResult, 
  UpdateFormRequest, 
  BatchUpdateResponse,
  QuestionType,
  QuestionTypeInfo 
} from './types';

/**
 * Creates a Google Form using the Google Forms API
 * @param formStructure - The form structure generated by our API
 * @param accessToken - Google OAuth access token
 * @returns Promise with the created form data
 */ 
export async function createGoogleForm(formStructure: GoogleFormStructure, accessToken: string): Promise<GoogleForm> {
  try {
    const response = await fetch('https://forms.googleapis.com/v1/forms', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(formStructure),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Failed to create Google Form: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error creating Google Form:', error);
    throw error;
  }
}

/**
 * Updates an existing Google Form using batch update
 * @param formId - The ID of the form to update
 * @param updateRequest - The update request following the Discovery Document format
 * @param accessToken - Google OAuth access token
 * @returns Promise with the updated form data
 */
export async function updateGoogleForm(formId: string, updateRequest: UpdateFormRequest, accessToken: string): Promise<BatchUpdateResponse> {
  try {
    const response = await fetch(`https://forms.googleapis.com/v1/forms/${formId}:batchUpdate`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updateRequest),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Failed to update Google Form: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error updating Google Form:', error);
    throw error;
  }
}

/**
 * Gets a Google Form by ID
 * @param formId - The ID of the form to retrieve
 * @param accessToken - Google OAuth access token
 * @returns Promise with the form data
 */
export async function getGoogleForm(formId: string, accessToken: string): Promise<GoogleForm> {
  try {
    const response = await fetch(`https://forms.googleapis.com/v1/forms/${formId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Failed to get Google Form: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error getting Google Form:', error);
    throw error;
  }
}

/**
 * Publishes a Google Form
 * @param formId - The ID of the form to publish
 * @param accessToken - Google OAuth access token
 * @returns Promise with the publish settings
 */
export async function publishGoogleForm(formId: string, accessToken: string) {
  try {
    const response = await fetch(`https://forms.googleapis.com/v1/forms/${formId}:setPublishSettings`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        publishSettings: {
          publishState: {
            isPublished: true,
            isAcceptingResponses: true,
          },
        },
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Failed to publish Google Form: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error publishing Google Form:', error);
    throw error;
  }
}

/**
 * Validates a form structure before sending to Google Forms API
 * Based on the Google Forms API Discovery Document
 * @param formStructure - The form structure to validate
 * @returns Validation result with errors if any
 */
export function validateFormStructure(formStructure: GoogleFormStructure): ValidationResult {
  const errors: string[] = [];

  // Check required top-level fields
  if (!formStructure.info) {
    errors.push('Form structure is missing "info" field');
  } else {
    if (!formStructure.info.title || formStructure.info.title.trim() === '') {
      errors.push('Form title is required');
    }
  }

  if (!formStructure.items || !Array.isArray(formStructure.items)) {
    errors.push('Form structure is missing "items" array');
  } else if (formStructure.items.length === 0) {
    errors.push('Form must have at least one item');
  } else {
    // Validate each item
    formStructure.items.forEach((item, index) => {
      if (!item.itemId || item.itemId.trim() === '') {
        errors.push(`Item ${index + 1}: itemId is required`);
      }

      if (!item.title || item.title.trim() === '') {
        errors.push(`Item ${index + 1}: title is required`);
      }

      // Check if item has at least one valid type
      const hasValidType = item.questionItem || item.questionGroupItem || 
                          item.textItem || item.imageItem || item.videoItem || 
                          item.pageBreakItem;

      if (!hasValidType) {
        errors.push(`Item ${index + 1}: must have at least one valid item type`);
      }

      // Validate question items
      if (item.questionItem) {
        const question = item.questionItem.question;
        if (!question.questionId || question.questionId.trim() === '') {
          errors.push(`Item ${index + 1}: questionId is required`);
        }

        // Check if question has at least one valid type
        const hasValidQuestionType = question.choiceQuestion || question.textQuestion || 
                                   question.scaleQuestion || question.dateQuestion || 
                                   question.timeQuestion || question.fileUploadQuestion ||
                                   question.rowQuestion || question.ratingQuestion;

        if (!hasValidQuestionType) {
          errors.push(`Item ${index + 1}: question must have at least one valid question type`);
        }

        // Validate choice questions
        if (question.choiceQuestion) {
          if (!question.choiceQuestion.options || question.choiceQuestion.options.length === 0) {
            errors.push(`Item ${index + 1}: choice question must have at least one option`);
          } else {
            question.choiceQuestion.options.forEach((option, optIndex) => {
              if (!option.value || option.value.trim() === '') {
                errors.push(`Item ${index + 1}, Option ${optIndex + 1}: value is required`);
              }
            });
          }
        }

        // Validate scale questions
        if (question.scaleQuestion) {
          if (question.scaleQuestion.low >= question.scaleQuestion.high) {
            errors.push(`Item ${index + 1}: scale question low value must be less than high value`);
          }
        }

        // Validate rating questions
        if (question.ratingQuestion) {
          if (!['STAR', 'HEART', 'THUMB'].includes(question.ratingQuestion.type)) {
            errors.push(`Item ${index + 1}: rating question type must be STAR, HEART, or THUMB`);
          }
          if (question.ratingQuestion.low >= question.ratingQuestion.high) {
            errors.push(`Item ${index + 1}: rating question low value must be less than high value`);
          }
        }

        // Validate file upload questions
        if (question.fileUploadQuestion) {
          if (question.fileUploadQuestion.maxFileSize <= 0) {
            errors.push(`Item ${index + 1}: file upload maxFileSize must be greater than 0`);
          }
          if (question.fileUploadQuestion.maxFiles <= 0) {
            errors.push(`Item ${index + 1}: file upload maxFiles must be greater than 0`);
          }
        }
      }
    });
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Converts our internal form structure to Google Forms API format
 * This ensures compatibility with the Google Forms API Discovery Document
 * @param formStructure - Our internal form structure
 * @returns Google Forms API compatible structure
 */
export function convertToGoogleFormsFormat(formStructure: GoogleFormStructure): GoogleFormStructure {
  return {
    ...formStructure,
    // Ensure all required fields are present
    info: {
      title: formStructure.info.title,
      description: formStructure.info.description || '',
    },
    items: formStructure.items.map(item => ({
      ...item,
      // Ensure itemId is present
      itemId: item.itemId || `item_${Math.random().toString(36).substr(2, 9)}`,
    })),
  };
}

/**
 * Gets the question type from a form item
 * @param item - The form item to analyze
 * @returns The question type or null if not a question
 */
export function getQuestionType(item: any): QuestionType | null {
  if (!item.questionItem?.question) return null;

  const question = item.questionItem.question;

  if (question.textQuestion) {
    return question.textQuestion.type === 'SHORT_ANSWER' ? 'TEXT_SHORT_ANSWER' : 'TEXT_PARAGRAPH';
  }
  if (question.choiceQuestion) {
    switch (question.choiceQuestion.type) {
      case 'RADIO': return 'CHOICE_RADIO';
      case 'CHECKBOX': return 'CHOICE_CHECKBOX';
      case 'DROP_DOWN': return 'CHOICE_DROP_DOWN';
      default: return null;
    }
  }
  if (question.scaleQuestion) return 'SCALE';
  if (question.dateQuestion) return 'DATE';
  if (question.timeQuestion) return 'TIME';
  if (question.fileUploadQuestion) return 'FILE_UPLOAD';
  if (question.rowQuestion) return 'ROW';
  if (question.ratingQuestion) {
    switch (question.ratingQuestion.type) {
      case 'STAR': return 'RATING_STAR';
      case 'HEART': return 'RATING_HEART';
      case 'THUMB': return 'RATING_THUMB';
      default: return null;
    }
  }

  return null;
}

/**
 * Gets information about question types
 * @returns Array of question type information
 */
export function getQuestionTypeInfo(): QuestionTypeInfo[] {
  return [
    { type: 'TEXT_SHORT_ANSWER', label: 'Short Text', description: 'Single-line text input' },
    { type: 'TEXT_PARAGRAPH', label: 'Long Text', description: 'Multi-line text input' },
    { type: 'CHOICE_RADIO', label: 'Multiple Choice', description: 'Single selection from options' },
    { type: 'CHOICE_CHECKBOX', label: 'Checkboxes', description: 'Multiple selections from options' },
    { type: 'CHOICE_DROP_DOWN', label: 'Dropdown', description: 'Single selection from dropdown' },
    { type: 'SCALE', label: 'Rating Scale', description: 'Numeric rating scale' },
    { type: 'DATE', label: 'Date', description: 'Date selection' },
    { type: 'TIME', label: 'Time', description: 'Time selection' },
    { type: 'FILE_UPLOAD', label: 'File Upload', description: 'File upload field' },
    { type: 'ROW', label: 'Grid Row', description: 'Row in a question group' },
    { type: 'RATING_STAR', label: 'Star Rating', description: 'Star-based rating' },
    { type: 'RATING_HEART', label: 'Heart Rating', description: 'Heart-based rating' },
    { type: 'RATING_THUMB', label: 'Thumb Rating', description: 'Thumb-based rating' },
  ];
} 